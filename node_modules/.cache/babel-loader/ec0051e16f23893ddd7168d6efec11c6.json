{"ast":null,"code":"import _defineProperty from \"C:\\\\xampp\\\\htdocs\\\\metaok\\\\my-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"C:\\\\xampp\\\\htdocs\\\\metaok\\\\my-app\\\\src\\\\lib\\\\video_stream.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { isSafari } from './helpers';\nconst videoStyles = {\n  display: 'flex'\n};\n\nclass VideoStream extends Component {\n  constructor(...args) {\n    super(...args);\n    this.stream = null;\n    this.streamWidth = 0;\n    this.streamHeight = 0;\n    this.video = null;\n    this.canvasContext = null;\n\n    this.stopCamera = () => {\n      if (!this.stream) return;\n      this.stream.getTracks().map(t => t.stop());\n      this.stream = null;\n      this.streamWidth = 0;\n      this.streamHeight = 0;\n      this.canvasContext = null;\n    };\n\n    this.startCamera = async () => {\n      this.stopCamera();\n\n      if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {\n        throw new Error('WebRTC API not supported in this browser');\n      }\n\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const cameras = devices.filter(device => device.kind === 'videoinput');\n      let videoMode = {\n        facingMode: 'user'\n      };\n\n      if (cameras.length > 1) {\n        const cameraIndex = this.props.rearCamera ? 1 : 0;\n        const cameraEnv = this.props.rearCamera ? 'environment' : 'user';\n        videoMode = isSafari() ? {\n          facingMode: {\n            exact: cameraEnv\n          }\n        } : {\n          deviceId: cameras[cameraIndex].deviceId\n        };\n      }\n\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: videoMode\n      });\n\n      if (this.video.srcObject !== undefined) {\n        this.video.srcObject = this.stream;\n      } else if (this.video.mozSrcObject !== undefined) {\n        this.video.mozSrcObject = this.stream;\n      } else if (window.URL.createObjectURL) {\n        this.video.src = window.URL.createObjectURL(this.stream);\n      } else if (window.webkitURL) {\n        this.video.src = window.webkitURL.createObjectURL(this.stream);\n      } else {\n        this.video.src = this.stream;\n      }\n\n      this.video.playsInline = true;\n      this.video.play(); // firefox does not emit `loadeddata` if video not playing\n\n      await this.streamLoadedPromise();\n      this.streamWidth = this.video.videoWidth;\n      this.streamHeight = this.video.videoHeight;\n\n      if (!this.canvasContext) {\n        const canvas = document.createElement('canvas');\n        canvas.width = this.streamWidth;\n        canvas.height = this.streamHeight;\n        this.canvasContext = canvas.getContext('2d');\n      }\n    };\n\n    this.streamLoadedPromise = () => new Promise((resolve, reject) => {\n      this.video.addEventListener('loadeddata', resolve, {\n        once: true\n      });\n      this.video.addEventListener('error', reject, {\n        once: true\n      });\n    });\n\n    this.captureFrame = () => {\n      this.canvasContext.drawImage(this.video, 0, 0, this.streamWidth, this.streamHeight);\n      return this.canvasContext.getImageData(0, 0, this.streamWidth, this.streamHeight);\n    };\n\n    this.drawFrame = () => {\n      window.requestAnimationFrame(() => {\n        if (!this.canvasContext) return;\n\n        const _this$captureFrame = this.captureFrame(),\n              data = _this$captureFrame.data;\n\n        this.props.onFrame({\n          data,\n          width: this.streamWidth,\n          height: this.streamHeight\n        });\n      });\n    };\n  }\n\n  async componentDidMount() {\n    let initSuccess = true;\n    let message = '';\n\n    try {\n      await this.startCamera();\n    } catch (e) {\n      message = \"Browser camera init error: \".concat(e);\n      initSuccess = false;\n    }\n\n    if (typeof this.props.onInit === 'function') {\n      this.props.onInit({\n        error: initSuccess,\n        message\n      }, this.drawFrame);\n    }\n  }\n\n  componentWillUnmount() {\n    this.stopCamera();\n  }\n\n  render() {\n    return React.createElement(\"video\", {\n      style: _objectSpread({}, videoStyles, {}, this.props.style),\n      ref: v => this.video = v,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115\n      },\n      __self: this\n    });\n  }\n\n}\n\n;\nVideoStream.propTypes = {\n  onInit: PropTypes.func.isRequired,\n  onFrame: PropTypes.func.isRequired,\n  style: PropTypes.object,\n  rearCamera: PropTypes.bool\n};\nVideoStream.defaultProps = {\n  style: {},\n  rearCamera: true\n};\nexport default VideoStream;","map":{"version":3,"sources":["C:/xampp/htdocs/metaok/my-app/src/lib/video_stream.js"],"names":["React","Component","PropTypes","isSafari","videoStyles","display","VideoStream","stream","streamWidth","streamHeight","video","canvasContext","stopCamera","getTracks","map","t","stop","startCamera","navigator","mediaDevices","getUserMedia","Error","devices","enumerateDevices","cameras","filter","device","kind","videoMode","facingMode","length","cameraIndex","props","rearCamera","cameraEnv","exact","deviceId","audio","srcObject","undefined","mozSrcObject","window","URL","createObjectURL","src","webkitURL","playsInline","play","streamLoadedPromise","videoWidth","videoHeight","canvas","document","createElement","width","height","getContext","Promise","resolve","reject","addEventListener","once","captureFrame","drawImage","getImageData","drawFrame","requestAnimationFrame","data","onFrame","componentDidMount","initSuccess","message","e","onInit","error","componentWillUnmount","render","style","v","propTypes","func","isRequired","object","bool","defaultProps"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { isSafari } from './helpers';\n\nconst videoStyles = {\n  display: 'flex',\n};\n\nclass VideoStream extends Component {\n  stream = null;\n  streamWidth = 0;\n  streamHeight = 0;\n  video = null;\n  canvasContext = null;\n\n  async componentDidMount() {\n    let initSuccess = true;\n    let message = '';\n    try {\n      await this.startCamera();\n    } catch (e) {\n      message = `Browser camera init error: ${e}`;\n      initSuccess = false;\n    }\n\n    if (typeof this.props.onInit === 'function') {\n      this.props.onInit({ error: initSuccess, message }, this.drawFrame);\n    }\n  }\n\n  componentWillUnmount() {\n    this.stopCamera();\n  }\n\n  stopCamera = () => {\n    if (!this.stream) return;\n    this.stream.getTracks().map(t => t.stop());\n    this.stream = null;\n    this.streamWidth = 0;\n    this.streamHeight = 0;\n    this.canvasContext = null;\n  };\n\n  startCamera = async () => {\n    this.stopCamera();\n\n    if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {\n      throw new Error('WebRTC API not supported in this browser');\n    }\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const cameras = devices.filter(device => device.kind === 'videoinput');\n    let videoMode = { facingMode: 'user' };\n    if (cameras.length > 1) {\n      const cameraIndex = this.props.rearCamera ? 1 : 0;\n      const cameraEnv = this.props.rearCamera ? 'environment' : 'user';\n      videoMode = isSafari() ? { facingMode: { exact: cameraEnv } } : { deviceId: cameras[cameraIndex].deviceId };\n    }\n\n    this.stream = await navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: videoMode,\n    });\n\n    if (this.video.srcObject !== undefined) {\n      this.video.srcObject = this.stream;\n    } else if (this.video.mozSrcObject !== undefined) {\n      this.video.mozSrcObject = this.stream;\n    } else if (window.URL.createObjectURL) {\n      this.video.src = window.URL.createObjectURL(this.stream);\n    } else if (window.webkitURL) {\n      this.video.src = window.webkitURL.createObjectURL(this.stream);\n    } else {\n      this.video.src = this.stream;\n    }\n\n    this.video.playsInline = true;\n    this.video.play(); // firefox does not emit `loadeddata` if video not playing\n    await this.streamLoadedPromise();\n\n    this.streamWidth = this.video.videoWidth;\n    this.streamHeight = this.video.videoHeight;\n\n    if (!this.canvasContext) {\n      const canvas = document.createElement('canvas');\n      canvas.width = this.streamWidth;\n      canvas.height = this.streamHeight;\n      this.canvasContext = canvas.getContext('2d');\n    }\n  };\n\n  streamLoadedPromise = () => new Promise((resolve, reject) => {\n    this.video.addEventListener('loadeddata', resolve, { once: true });\n    this.video.addEventListener('error', reject, { once: true });\n  });\n\n  captureFrame = () => {\n    this.canvasContext.drawImage(this.video, 0, 0, this.streamWidth, this.streamHeight);\n    return this.canvasContext.getImageData(0, 0, this.streamWidth, this.streamHeight);\n  }\n\n  drawFrame = () => {\n    window.requestAnimationFrame(() => {\n      if (!this.canvasContext) return;\n      const { data } = this.captureFrame();\n      this.props.onFrame({\n        data,\n        width: this.streamWidth,\n        height: this.streamHeight,\n      });\n    });\n  };\n\n  render() {\n    return <video style={{...videoStyles, ...this.props.style}} ref={v => (this.video = v)} />\n  }\n};\n\nVideoStream.propTypes = {\n  onInit: PropTypes.func.isRequired,\n  onFrame: PropTypes.func.isRequired,\n  style: PropTypes.object,\n  rearCamera: PropTypes.bool,\n};\n\nVideoStream.defaultProps = {\n  style: {},\n  rearCamera: true,\n};\n\nexport default VideoStream;\n"]},"metadata":{},"sourceType":"module"}